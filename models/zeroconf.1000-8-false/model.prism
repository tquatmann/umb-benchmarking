mdp
const bool reset = false;
const int N = 1000;
const int K = 8;
const double loss = 1/10;
const double old = (1000 / 65024);
const double new = (1 - old);
const int CONSEC = 2;
const int TRANSTIME = 1;
const int LONGWAIT = 60;
const int DEFEND = 10;
const int TIME_MAX_X = 60;
const int TIME_MAX_Y = 10;
const int TIME_MAX_Z = 1;
const int MAXCOLL = 10;
const int B0 = 20;
const int B1 = 8;



module environment
	b_ip7: [0..2] init 0;
	b_ip6: [0..2] init 0;
	b_ip5: [0..2] init 0;
	b_ip4: [0..2] init 0;
	b_ip3: [0..2] init 0;
	b_ip2: [0..2] init 0;
	b_ip1: [0..2] init 0;
	b_ip0: [0..2] init 0;
	n: [0..8] init 0;
	n0: [0..B0] init 0;
	n1: [0..B1] init 0;
	b: [0..2] init 0;
	z: [0..1] init 0;
	ip_mess: [0..2] init 0;
	[reset] true -> 1 : (b_ip7' = 0) & (b_ip6' = 0) & (b_ip5' = 0) & (b_ip4' = 0) & (b_ip3' = 0) & (b_ip2' = 0) & (b_ip1' = 0) & (b_ip0' = 0) & (n' = (reset ? 0 : n)) & (n0' = (min(B0, (n0 + n1)))) & (n1' = 0) & (ip_mess' = 0);
	[time] (((((l > 0) & (b = 0)) & (n = 0)) & (n0 = 0)) & (n1 = 0)) -> 1 : (b' = b);
	[time] (((l > 0) & (b > 0)) & (z < 1)) -> 1 : (z' = (min((z + 1), TIME_MAX_Z)));
	[send] ((l > 0) & (n = 0)) -> 1 : (b_ip0' = ip) & (n' = (n + 1));
	[send] ((l > 0) & (n = 1)) -> 1 : (b_ip1' = ip) & (n' = (n + 1));
	[send] ((l > 0) & (n = 2)) -> 1 : (b_ip2' = ip) & (n' = (n + 1));
	[send] ((l > 0) & (n = 3)) -> 1 : (b_ip3' = ip) & (n' = (n + 1));
	[send] ((l > 0) & (n = 4)) -> 1 : (b_ip4' = ip) & (n' = (n + 1));
	[send] ((l > 0) & (n = 5)) -> 1 : (b_ip5' = ip) & (n' = (n + 1));
	[send] ((l > 0) & (n = 6)) -> 1 : (b_ip6' = ip) & (n' = (n + 1));
	[send] ((l > 0) & (n = 7)) -> 1 : (b_ip7' = ip) & (n' = (n + 1));
	[send] ((l > 0) & (n = 8)) -> 1 : (n' = n);
	[] (((l > 0) & (b = 0)) & (n > 0)) -> (1 - loss) : (b_ip7' = 0) & (b_ip6' = b_ip7) & (b_ip5' = b_ip6) & (b_ip4' = b_ip5) & (b_ip3' = b_ip4) & (b_ip2' = b_ip3) & (b_ip1' = b_ip2) & (b_ip0' = b_ip1) & (n' = (n - 1)) & (b' = 1) & (ip_mess' = b_ip0) + loss : (b_ip7' = 0) & (b_ip6' = b_ip7) & (b_ip5' = b_ip6) & (b_ip4' = b_ip5) & (b_ip3' = b_ip4) & (b_ip2' = b_ip3) & (b_ip1' = b_ip2) & (b_ip0' = b_ip1) & (n' = (n - 1));
	[] (((l > 0) & (b = 0)) & (n0 > 0)) -> (1 - loss) : (n0' = (n0 - 1)) & (b' = 2) & (ip_mess' = 0) + loss : (n0' = (n0 - 1));
	[] (((l > 0) & (b = 0)) & (n1 > 0)) -> (1 - loss) : (n1' = (n1 - 1)) & (b' = 2) & (ip_mess' = 1) + loss : (n1' = (n1 - 1));
	[] (((l > 0) & (b = 1)) & (ip_mess = 0)) -> 1 : (n0' = (min((n0 + 1), B0))) & (b' = 0) & (z' = 0) & (ip_mess' = 0);
	[] (((l > 0) & (b = 1)) & (ip_mess = 1)) -> 1 : (n1' = (min((n1 + 1), B1))) & (b' = 0) & (z' = 0) & (ip_mess' = 0);
	[] (((l > 0) & (b = 1)) & (ip_mess = 2)) -> 1 : (b' = 0) & (z' = 0) & (ip_mess' = 0);
	[rec] ((l > 0) & (b = 2)) -> 1 : (b' = 0) & (z' = 0) & (ip_mess' = 0);
endmodule

module host0
	x: [0..TIME_MAX_X] init 0;
	y: [0..TIME_MAX_Y] init 0;
	coll: [0..MAXCOLL] init 0;
	probes: [0..K] init 0;
	mess: [0..1] init 0;
	defend: [0..1] init 0;
	ip: [1..2] init 1;
	l: [0..4] init 1;
	[reset] (l = 0) -> 1 : (l' = 1);
	[rec] (l = 1) -> 1 : true;
	[] ((l = 1) & (coll < MAXCOLL)) -> ((1 / 3) * old) : (x' = 0) & (ip' = 1) & (l' = 2) + ((1 / 3) * old) : (x' = 1) & (ip' = 1) & (l' = 2) + ((1 / 3) * old) : (x' = 2) & (ip' = 1) & (l' = 2) + ((1 / 3) * new) : (x' = 0) & (ip' = 2) & (l' = 2) + ((1 / 3) * new) : (x' = 1) & (ip' = 2) & (l' = 2) + ((1 / 3) * new) : (x' = 2) & (ip' = 2) & (l' = 2);
	[time] (((l = 1) & (coll = MAXCOLL)) & (x < LONGWAIT)) -> 1 : (x' = (min((x + 1), TIME_MAX_X)));
	[] (((l = 1) & (coll = MAXCOLL)) & (x = LONGWAIT)) -> ((1 / 3) * old) : (x' = 0) & (ip' = 1) & (l' = 2) + ((1 / 3) * old) : (x' = 1) & (ip' = 1) & (l' = 2) + ((1 / 3) * old) : (x' = 2) & (ip' = 1) & (l' = 2) + ((1 / 3) * new) : (x' = 0) & (ip' = 2) & (l' = 2) + ((1 / 3) * new) : (x' = 1) & (ip' = 2) & (l' = 2) + ((1 / 3) * new) : (x' = 2) & (ip' = 2) & (l' = 2);
	[time] ((l = 2) & (x < 2)) -> 1 : (x' = (min((x + 1), 2)));
	[send] (((l = 2) & (x = 2)) & (probes < K)) -> 1 : (x' = 0) & (probes' = (probes + 1));
	[] (((l = 2) & (x = 2)) & (probes = K)) -> 1 : (x' = 0) & (coll' = 0) & (probes' = 0) & (l' = 3);
	[rec] ((l = 2) & (ip_mess != ip)) -> 1 : (l' = l);
	[rec] ((l = 2) & (ip_mess = ip)) -> 1 : (x' = 0) & (coll' = (min((coll + 1), MAXCOLL))) & (probes' = 0) & (l' = 0);
	[time] ((((l = 3) & (mess = 0)) & (defend = 0)) & (x < CONSEC)) -> 1 : (x' = (min((x + 1), TIME_MAX_X)));
	[time] ((((l = 3) & (mess = 0)) & (defend = 1)) & (x < CONSEC)) -> 1 : (x' = (min((x + 1), TIME_MAX_X))) & (y' = (min((y + 1), DEFEND)));
	[rec] ((((l = 3) & (mess = 0)) & (ip_mess = ip)) & ((defend = 0) | (y >= DEFEND))) -> 1 : (y' = 0) & (mess' = 1) & (defend' = 1);
	[rec] ((((l = 3) & (mess = 0)) & (ip_mess = ip)) & ((defend = 0) | (y < DEFEND))) -> 1 : (x' = 0) & (y' = 0) & (probes' = 0) & (defend' = 0) & (l' = 0);
	[rec] (((l = 3) & (mess = 0)) & (ip_mess != ip)) -> 1 : (l' = l);
	[send] ((l = 3) & (mess = 1)) -> 1 : (mess' = 0);
	[send] ((((l = 3) & (mess = 0)) & (x = CONSEC)) & (probes < 1)) -> 1 : (x' = 0) & (probes' = (probes + 1));
	[send] ((((l = 3) & (mess = 0)) & (x = CONSEC)) & (probes = 1)) -> 1 : (x' = 0) & (y' = 0) & (probes' = 0) & (l' = 4);
	[] (l = 4) -> 1 : true;
endmodule


