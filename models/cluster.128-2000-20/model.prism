ctmc
const int N = 128;
const double T = 2000;
const double t = 20;
const int left_mx = 128;
const int right_mx = 128;
const double ws_fail = (1 / 500);
const double switch_fail = (1 / 4000);
const double line_fail = (1 / 5000);
const int k = floor((3/4 * 128));


formula minimum = ((((left_n >= k) & toleft_n) | ((right_n >= k) & toright_n)) | (((((left_n + right_n) >= k) & toleft_n) & line_n) & toright_n));

module Left
	left: bool init false;
	left_n: [0..left_mx] init left_mx;
	<startLeft> (!(left) & (left_n < left_mx)) -> 1 : (left' = true);
	<repairLeft> (left & (left_n < left_mx)) -> 1 : (left' = false) & (left_n' = (left_n + 1));
	<> (left_n > 0) -> (ws_fail * left_n) : (left_n' = (left_n - 1));
endmodule

module Right
	right: bool init false;
	right_n: [0..right_mx] init right_mx;
	<startRight> (!(right) & (right_n < right_mx)) -> 1 : (right' = true);
	<repairRight> (right & (right_n < right_mx)) -> 1 : (right' = false) & (right_n' = (right_n + 1));
	<> (right_n > 0) -> (ws_fail * right_n) : (right_n' = (right_n - 1));
endmodule

module Repairman
	r: bool init false;
	<startLeft> !(r) -> 10 : (r' = true);
	<startRight> !(r) -> 10 : (r' = true);
	<startToLeft> !(r) -> 10 : (r' = true);
	<startToRight> !(r) -> 10 : (r' = true);
	<startLine> !(r) -> 10 : (r' = true);
	<repairLeft> r -> 2 : (r' = false);
	<repairRight> r -> 2 : (r' = false);
	<repairToLeft> r -> 1/4 : (r' = false);
	<repairToRight> r -> 1/4 : (r' = false);
	<repairLine> r -> 1/8 : (r' = false);
endmodule

module Line
	line: bool init false;
	line_n: bool init true;
	<startLine> (!(line) & !(line_n)) -> 1 : (line' = true);
	<repairLine> (line & !(line_n)) -> 1 : (line' = false) & (line_n' = true);
	<> line_n -> line_fail : (line_n' = false);
endmodule

module ToLeft
	toleft: bool init false;
	toleft_n: bool init true;
	<startToLeft> (!(toleft) & !(toleft_n)) -> 1 : (toleft' = true);
	<repairToLeft> (toleft & !(toleft_n)) -> 1 : (toleft' = false) & (toleft_n' = true);
	<> toleft_n -> switch_fail : (toleft_n' = false);
endmodule

module ToRight
	toright: bool init false;
	toright_n: bool init true;
	<startToRight> (!(toright) & !(toright_n)) -> 1 : (toright' = true);
	<repairToRight> (toright & !(toright_n)) -> 1 : (toright' = false) & (toright_n' = true);
	<> toright_n -> switch_fail : (toright_n' = false);
endmodule

rewards "percent_op"
	true: ((100 * (left_n + right_n)) / (2 * N));
endrewards

rewards "time_not_min"
	!(minimum): 1;
endrewards

rewards "num_repairs"
	[repairLeft] true: 1;
	[repairRight] true: 1;
	[repairToLeft] true: 1;
	[repairToRight] true: 1;
	[repairLine] true: 1;
endrewards

label "minimum" = ((((left_n >= k) & toleft_n) | ((right_n >= k) & toright_n)) | (((((left_n + right_n) >= k) & toleft_n) & line_n) & toright_n));
label "premium" = ((((left_n >= left_mx) & toleft_n) | ((right_n >= right_mx) & toright_n)) | (((((left_n + right_n) >= left_mx) & toleft_n) & line_n) & toright_n));

