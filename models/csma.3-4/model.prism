mdp
const int sigma = 1;
const int lambda = 30;
const int N = 3;
const int K = 4;
const int slot = (2 * sigma);
const int M = (floor((2 ^ K)) - 1);


formula min_backoff_after_success = (min((min(((s1 = 4) ? cd1 : (K + 1)), ((s2 = 4) ? cd2 : (K + 1)))), ((s3 = 4) ? cd3 : (K + 1))));
formula min_collisions = (min((min(cd1, cd2)), cd3));
formula max_collisions = (max((max(cd1, cd2)), cd3));

module bus
	b: [0..2] init 0;
	y1: [0..(sigma + 1)] init 0;
	y2: [0..(sigma + 1)] init 0;
	[send1] (b = 0) -> 1 : (b' = 1);
	[send2] (b = 0) -> 1 : (b' = 1);
	[send3] (b = 0) -> 1 : (b' = 1);
	[send1] (((b = 1) | (b = 2)) & (y1 < sigma)) -> 1 : (b' = 2);
	[send2] (((b = 1) | (b = 2)) & (y1 < sigma)) -> 1 : (b' = 2);
	[send3] (((b = 1) | (b = 2)) & (y1 < sigma)) -> 1 : (b' = 2);
	[end1] (b = 1) -> 1 : (b' = 0) & (y1' = 0);
	[end2] (b = 1) -> 1 : (b' = 0) & (y1' = 0);
	[end3] (b = 1) -> 1 : (b' = 0) & (y1' = 0);
	[busy1] (((b = 1) | (b = 2)) & (y1 >= sigma)) -> 1 : (b' = b);
	[busy2] (((b = 1) | (b = 2)) & (y1 >= sigma)) -> 1 : (b' = b);
	[busy3] (((b = 1) | (b = 2)) & (y1 >= sigma)) -> 1 : (b' = b);
	[cd] ((b = 2) & (y2 <= sigma)) -> 1 : (b' = 0) & (y1' = 0) & (y2' = 0);
	[time] (b = 0) -> 1 : (y1' = 0);
	[time] (b = 1) -> 1 : (y1' = (min((y1 + 1), (sigma + 1))));
	[time] ((b = 2) & (y2 < sigma)) -> 1 : (y1' = (min((y1 + 1), (sigma + 1)))) & (y2' = (min((y2 + 1), (sigma + 1))));
endmodule

module station1
	s1: [0..5] init 0;
	x1: [0..(max(lambda, slot))] init 0;
	bc1: [0..M] init 0;
	cd1: [0..K] init 0;
	[send1] (s1 = 0) -> 1 : (s1' = 1) & (x1' = 0);
	[busy1] (s1 = 0) -> 1 : (s1' = 2) & (x1' = 0) & (cd1' = (min(K, (cd1 + 1))));
	[time] ((s1 = 1) & (x1 < lambda)) -> 1 : (x1' = (min((x1 + 1), lambda)));
	[end1] ((s1 = 1) & (x1 = lambda)) -> 1 : (s1' = 4) & (x1' = 0);
	[cd] (s1 = 1) -> 1 : (s1' = 2) & (x1' = 0) & (cd1' = (min(K, (cd1 + 1))));
	[cd] !((s1 = 1)) -> 1 : (s1' = s1);
	[] ((s1 = 2) & (cd1 = 1)) -> (1 / 2) : (s1' = 3) & (bc1' = 0) + (1 / 2) : (s1' = 3) & (bc1' = 1);
	[] ((s1 = 2) & (cd1 = 2)) -> (1 / 4) : (s1' = 3) & (bc1' = 0) + (1 / 4) : (s1' = 3) & (bc1' = 1) + (1 / 4) : (s1' = 3) & (bc1' = 2) + (1 / 4) : (s1' = 3) & (bc1' = 3);
	[] ((s1 = 2) & (cd1 = 3)) -> (1 / 8) : (s1' = 3) & (bc1' = 0) + (1 / 8) : (s1' = 3) & (bc1' = 1) + (1 / 8) : (s1' = 3) & (bc1' = 2) + (1 / 8) : (s1' = 3) & (bc1' = 3) + (1 / 8) : (s1' = 3) & (bc1' = 4) + (1 / 8) : (s1' = 3) & (bc1' = 5) + (1 / 8) : (s1' = 3) & (bc1' = 6) + (1 / 8) : (s1' = 3) & (bc1' = 7);
	[] ((s1 = 2) & (cd1 = 4)) -> (1 / 16) : (s1' = 3) & (bc1' = 0) + (1 / 16) : (s1' = 3) & (bc1' = 1) + (1 / 16) : (s1' = 3) & (bc1' = 2) + (1 / 16) : (s1' = 3) & (bc1' = 3) + (1 / 16) : (s1' = 3) & (bc1' = 4) + (1 / 16) : (s1' = 3) & (bc1' = 5) + (1 / 16) : (s1' = 3) & (bc1' = 6) + (1 / 16) : (s1' = 3) & (bc1' = 7) + (1 / 16) : (s1' = 3) & (bc1' = 8) + (1 / 16) : (s1' = 3) & (bc1' = 9) + (1 / 16) : (s1' = 3) & (bc1' = 10) + (1 / 16) : (s1' = 3) & (bc1' = 11) + (1 / 16) : (s1' = 3) & (bc1' = 12) + (1 / 16) : (s1' = 3) & (bc1' = 13) + (1 / 16) : (s1' = 3) & (bc1' = 14) + (1 / 16) : (s1' = 3) & (bc1' = 15);
	[time] ((s1 = 3) & (x1 < slot)) -> 1 : (x1' = (x1 + 1));
	[time] (((s1 = 3) & (x1 = slot)) & (bc1 > 0)) -> 1 : (x1' = 1) & (bc1' = (bc1 - 1));
	[send1] (((s1 = 3) & (x1 = slot)) & (bc1 = 0)) -> 1 : (s1' = 1) & (x1' = 0);
	[busy1] (((s1 = 3) & (x1 = slot)) & (bc1 = 0)) -> 1 : (s1' = 2) & (x1' = 0) & (cd1' = (min(K, (cd1 + 1))));
	[time] (s1 >= 4) -> 1 : (x1' = 0);
endmodule

module station2
	s2: [0..5] init 0;
	x2: [0..(max(lambda, slot))] init 0;
	bc2: [0..M] init 0;
	cd2: [0..K] init 0;
	[send2] (s2 = 0) -> 1 : (s2' = 1) & (x2' = 0);
	[busy2] (s2 = 0) -> 1 : (s2' = 2) & (x2' = 0) & (cd2' = (min(K, (cd2 + 1))));
	[time] ((s2 = 1) & (x2 < lambda)) -> 1 : (x2' = (min((x2 + 1), lambda)));
	[end2] ((s2 = 1) & (x2 = lambda)) -> 1 : (s2' = 4) & (x2' = 0);
	[cd] (s2 = 1) -> 1 : (s2' = 2) & (x2' = 0) & (cd2' = (min(K, (cd2 + 1))));
	[cd] !((s2 = 1)) -> 1 : (s2' = s2);
	[] ((s2 = 2) & (cd2 = 1)) -> (1 / 2) : (s2' = 3) & (bc2' = 0) + (1 / 2) : (s2' = 3) & (bc2' = 1);
	[] ((s2 = 2) & (cd2 = 2)) -> (1 / 4) : (s2' = 3) & (bc2' = 0) + (1 / 4) : (s2' = 3) & (bc2' = 1) + (1 / 4) : (s2' = 3) & (bc2' = 2) + (1 / 4) : (s2' = 3) & (bc2' = 3);
	[] ((s2 = 2) & (cd2 = 3)) -> (1 / 8) : (s2' = 3) & (bc2' = 0) + (1 / 8) : (s2' = 3) & (bc2' = 1) + (1 / 8) : (s2' = 3) & (bc2' = 2) + (1 / 8) : (s2' = 3) & (bc2' = 3) + (1 / 8) : (s2' = 3) & (bc2' = 4) + (1 / 8) : (s2' = 3) & (bc2' = 5) + (1 / 8) : (s2' = 3) & (bc2' = 6) + (1 / 8) : (s2' = 3) & (bc2' = 7);
	[] ((s2 = 2) & (cd2 = 4)) -> (1 / 16) : (s2' = 3) & (bc2' = 0) + (1 / 16) : (s2' = 3) & (bc2' = 1) + (1 / 16) : (s2' = 3) & (bc2' = 2) + (1 / 16) : (s2' = 3) & (bc2' = 3) + (1 / 16) : (s2' = 3) & (bc2' = 4) + (1 / 16) : (s2' = 3) & (bc2' = 5) + (1 / 16) : (s2' = 3) & (bc2' = 6) + (1 / 16) : (s2' = 3) & (bc2' = 7) + (1 / 16) : (s2' = 3) & (bc2' = 8) + (1 / 16) : (s2' = 3) & (bc2' = 9) + (1 / 16) : (s2' = 3) & (bc2' = 10) + (1 / 16) : (s2' = 3) & (bc2' = 11) + (1 / 16) : (s2' = 3) & (bc2' = 12) + (1 / 16) : (s2' = 3) & (bc2' = 13) + (1 / 16) : (s2' = 3) & (bc2' = 14) + (1 / 16) : (s2' = 3) & (bc2' = 15);
	[time] ((s2 = 3) & (x2 < slot)) -> 1 : (x2' = (x2 + 1));
	[time] (((s2 = 3) & (x2 = slot)) & (bc2 > 0)) -> 1 : (x2' = 1) & (bc2' = (bc2 - 1));
	[send2] (((s2 = 3) & (x2 = slot)) & (bc2 = 0)) -> 1 : (s2' = 1) & (x2' = 0);
	[busy2] (((s2 = 3) & (x2 = slot)) & (bc2 = 0)) -> 1 : (s2' = 2) & (x2' = 0) & (cd2' = (min(K, (cd2 + 1))));
	[time] (s2 >= 4) -> 1 : (x2' = 0);
endmodule

module station3
	s3: [0..5] init 0;
	x3: [0..(max(lambda, slot))] init 0;
	bc3: [0..M] init 0;
	cd3: [0..K] init 0;
	[send3] (s3 = 0) -> 1 : (s3' = 1) & (x3' = 0);
	[busy3] (s3 = 0) -> 1 : (s3' = 2) & (x3' = 0) & (cd3' = (min(K, (cd3 + 1))));
	[time] ((s3 = 1) & (x3 < lambda)) -> 1 : (x3' = (min((x3 + 1), lambda)));
	[end3] ((s3 = 1) & (x3 = lambda)) -> 1 : (s3' = 4) & (x3' = 0);
	[cd] (s3 = 1) -> 1 : (s3' = 2) & (x3' = 0) & (cd3' = (min(K, (cd3 + 1))));
	[cd] !((s3 = 1)) -> 1 : (s3' = s3);
	[] ((s3 = 2) & (cd3 = 1)) -> (1 / 2) : (s3' = 3) & (bc3' = 0) + (1 / 2) : (s3' = 3) & (bc3' = 1);
	[] ((s3 = 2) & (cd3 = 2)) -> (1 / 4) : (s3' = 3) & (bc3' = 0) + (1 / 4) : (s3' = 3) & (bc3' = 1) + (1 / 4) : (s3' = 3) & (bc3' = 2) + (1 / 4) : (s3' = 3) & (bc3' = 3);
	[] ((s3 = 2) & (cd3 = 3)) -> (1 / 8) : (s3' = 3) & (bc3' = 0) + (1 / 8) : (s3' = 3) & (bc3' = 1) + (1 / 8) : (s3' = 3) & (bc3' = 2) + (1 / 8) : (s3' = 3) & (bc3' = 3) + (1 / 8) : (s3' = 3) & (bc3' = 4) + (1 / 8) : (s3' = 3) & (bc3' = 5) + (1 / 8) : (s3' = 3) & (bc3' = 6) + (1 / 8) : (s3' = 3) & (bc3' = 7);
	[] ((s3 = 2) & (cd3 = 4)) -> (1 / 16) : (s3' = 3) & (bc3' = 0) + (1 / 16) : (s3' = 3) & (bc3' = 1) + (1 / 16) : (s3' = 3) & (bc3' = 2) + (1 / 16) : (s3' = 3) & (bc3' = 3) + (1 / 16) : (s3' = 3) & (bc3' = 4) + (1 / 16) : (s3' = 3) & (bc3' = 5) + (1 / 16) : (s3' = 3) & (bc3' = 6) + (1 / 16) : (s3' = 3) & (bc3' = 7) + (1 / 16) : (s3' = 3) & (bc3' = 8) + (1 / 16) : (s3' = 3) & (bc3' = 9) + (1 / 16) : (s3' = 3) & (bc3' = 10) + (1 / 16) : (s3' = 3) & (bc3' = 11) + (1 / 16) : (s3' = 3) & (bc3' = 12) + (1 / 16) : (s3' = 3) & (bc3' = 13) + (1 / 16) : (s3' = 3) & (bc3' = 14) + (1 / 16) : (s3' = 3) & (bc3' = 15);
	[time] ((s3 = 3) & (x3 < slot)) -> 1 : (x3' = (x3 + 1));
	[time] (((s3 = 3) & (x3 = slot)) & (bc3 > 0)) -> 1 : (x3' = 1) & (bc3' = (bc3 - 1));
	[send3] (((s3 = 3) & (x3 = slot)) & (bc3 = 0)) -> 1 : (s3' = 1) & (x3' = 0);
	[busy3] (((s3 = 3) & (x3 = slot)) & (bc3 = 0)) -> 1 : (s3' = 2) & (x3' = 0) & (cd3' = (min(K, (cd3 + 1))));
	[time] (s3 >= 4) -> 1 : (x3' = 0);
endmodule

rewards "time"
	[time] true: 1;
endrewards

label "all_delivered" = (((s1 = 4) & (s2 = 4)) & (s3 = 4));
label "one_delivered" = (((s1 = 4) | (s2 = 4)) | (s3 = 4));
label "collision_max_backoff" = (((((cd1 = K) & (s1 = 1)) & (b = 2)) | (((cd2 = K) & (s2 = 1)) & (b = 2))) | (((cd3 = K) & (s3 = 1)) & (b = 2)));

